#!/usr/bin/env python3
"""
signer_logic.py
Contains the core GPG signing and hashing logic for the Helwan ISO Signer GUI.
- Supports SHA256, SHA512, SHA1, MD5.
- Includes comprehensive progress tracking for the entire process.
"""
import subprocess, sys, hashlib, textwrap, tempfile, shutil, os
from pathlib import Path
from datetime import datetime

# Helper function to run system commands.
def run(cmd, capture=False, check=True, log_callback=None):
    if log_callback:
        log_callback(f"Executing: {' '.join(cmd)}")
    
    if capture:
        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if check and p.returncode != 0:
            raise RuntimeError(f"Command failed: {' '.join(cmd)}\n{p.stderr.strip()}")
        return p.stdout
    else:
        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if check and p.returncode != 0:
            raise RuntimeError(f"Command failed: {' '.join(cmd)} (exit {p.returncode})\n{p.stderr.strip()}")
        if log_callback:
             log_callback(f"Command Output:\n{p.stdout.strip()}")
        return None

# Function to compute the hash of a large file efficiently with global progress updates.
def compute_hash(path, algo, log_callback, total_progress_start, total_progress_end, total_progress_callback):
    h = algo()
    file_size = os.path.getsize(path)
    bytes_read = 0
    chunk_size = 1024 * 1024 # 1MB chunk
    total_progress_range = total_progress_end - total_progress_start
    
    log_callback(f"Calculating {algo.__name__.upper()}...")

    with open(path, "rb") as f:
        while True:
            chunk = f.read(chunk_size)
            if not chunk:
                break
            h.update(chunk)
            bytes_read += len(chunk)
            
            # Send global progress update
            if total_progress_callback:
                hash_percent_local = (bytes_read / file_size)
                global_progress = total_progress_start + (hash_percent_local * total_progress_range)
                total_progress_callback(int(global_progress))
                
    return h.hexdigest()

# Function to find the Fingerprint (FPR) of the first existing secret key.
def find_existing_secret_fpr():
    out = run(["gpg", "--list-secret-keys", "--with-colons"], capture=True, check=False)
    if not out:
        return None
    lines = out.splitlines()
    for i, ln in enumerate(lines):
        if ln.startswith("sec:"):
            for j in range(i+1, min(i+6, len(lines))):
                if lines[j].startswith("fpr:"):
                    parts = lines[j].split(":")
                    if len(parts) > 9:
                        return parts[9]
    return None

# Function to generate a new GPG key without a passphrase.
def generate_no_pass_key(log_callback):
    batch = textwrap.dedent("""
    %no-protection
    Key-Type: RSA
    Key-Length: 4096
    Name-Real: Helwan ISO Signing
    Name-Comment: auto-generated by signer_logic.py
    Name-Email: helwan@localhost
    Expire-Date: 0
    %commit
    """).strip()
    log_callback("No secret key found — Auto-generating an unprotected key for signing (Security Warning).")
    
    tfpath = ""
    try:
        with tempfile.NamedTemporaryFile("w", delete=False) as tf:
            tf.write(batch)
            tfpath = tf.name
        
        run(["gpg", "--batch", "--gen-key", tfpath], log_callback=log_callback)
    finally:
        if Path(tfpath).exists():
            try:
                Path(tfpath).unlink()
            except Exception:
                pass
    return find_existing_secret_fpr()

# Function to export the public key to an armored file.
def export_pubkey(fpr, outpath, log_callback):
    if fpr:
        run(["gpg", "--armor", "--output", str(outpath), "--export", fpr], log_callback=log_callback)
    else:
        run(["gpg", "--armor", "--output", str(outpath), "--export"], log_callback=log_callback)

# Function to extract the FPR from the exported public key file.
def extract_fpr_from_pubkey(pubkeyfile):
    out = run(["gpg", "--with-colons", "--import-options", "show-only", "--import", str(pubkeyfile)], capture=True, check=False)
    if not out:
        return None
    for ln in out.splitlines():
        if ln.startswith("fpr:"):
            parts = ln.split(":")
            if len(parts) > 9:
                return parts[9]
    return None

# Function to verify the signature of an ISO file (The full GPG verification step).
def verify_iso_signature(iso_path_str, sig_path_str, log_callback):
    iso_path = Path(iso_path_str)
    sig_path = Path(sig_path_str)
    
    if not iso_path.exists() or not iso_path.is_file():
        raise FileNotFoundError(f"ISO file not found: {iso_path}")
    if not sig_path.exists() or not sig_path.is_file():
        raise FileNotFoundError(f"Signature file not found: {sig_path}")
        
    log_callback(f"Starting verification of {iso_path.name} against {sig_path.name}...")
    
    try:
        # GPG verification command
        run(["gpg", "--verify", str(sig_path), str(iso_path)], log_callback=log_callback)
        log_callback("✅ Signature verification successful! (GPG output above)")
        return True
    except Exception as e:
        log_callback(f"❌ Signature verification FAILED. Error: {e}")
        return False


# The main execution function
def execute_signing_process(iso_path_str, output_dir_str, hash_algorithms, log_callback, progress_callback):
    
    # 0. Initial Setup and Validation (0% - 5%)
    progress_callback(0)
    
    iso_path = Path(iso_path_str)
    
    if shutil.which("gpg") is None:
        raise RuntimeError("gpg is not installed. Please install it first (e.g., apt install gnupg).")

    if not iso_path.exists() or not iso_path.is_file():
        raise FileNotFoundError(f"ISO file not found: {iso_path}")

    # Setup output directory structure
    base_output_dir = Path(output_dir_str)
    base_output_dir.mkdir(exist_ok=True)
    iso_basename = iso_path.stem
    dest_dir = base_output_dir / iso_basename
    
    if dest_dir.exists():
        ts = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
        dest_dir = base_output_dir / f"{iso_basename}_{ts}"
    dest_dir.mkdir(parents=True, exist_ok=False)

    # Define output file paths
    sig_bin = dest_dir / (iso_path.name + ".sig")
    sig_asc = dest_dir / (iso_path.name + ".sig.asc")
    pubkey_file = dest_dir / "helwan-key.asc"
    report_file = dest_dir / f"{iso_path.name}.report.txt"
    log_file = dest_dir / "sign_iso.log"

    def file_log(msg):
        with open(log_file, "a", encoding="utf-8") as L:
            L.write(f"{datetime.utcnow().isoformat()}Z  {msg}\n")
    
    def combined_log(msg):
        file_log(msg)
        log_callback(msg)

    combined_log("Starting process")
    combined_log(f"Working — The output will be in: {dest_dir.resolve()}")
    progress_callback(5) # 5% complete

    # 1. Identify or Generate Secret Key (5% - 10%)
    fpr = find_existing_secret_fpr()
    if not fpr:
        fpr = generate_no_pass_key(combined_log)
            
    if not fpr:
        raise RuntimeError("No secret key found and none was generated.")
        
    long_key_id = fpr[-16:]
    combined_log(f"Using key FPR={fpr} LONG={long_key_id}")
    progress_callback(10) # 10% complete

    # 2. Create Detached Signatures (10% - 20%)
    combined_log("Creating signatures...")
    try:
        # Binary Signature
        run(["gpg", "--output", str(sig_bin), "--detach-sign", "--local-user", fpr, str(iso_path)], log_callback=combined_log)
        # ASCII Armored Signature
        run(["gpg", "--armor", "--output", str(sig_asc), "--detach-sign", "--local-user", fpr, str(iso_path)], log_callback=combined_log)
        combined_log("Signatures created successfully.")
    except Exception as e:
        raise RuntimeError(f"Failed to create signature via gpg. (Is key protected by a passphrase?): {e}")
    progress_callback(20) # 20% complete

    # 3. Export Public Key (20% - 25%)
    combined_log(f"Exporting Public Key to: {pubkey_file.name}")
    export_pubkey(fpr, pubkey_file, combined_log)
    combined_log(f"Public key exported: {pubkey_file}")
    progress_callback(25) # 25% complete

    # 4. Calculate Hashes (25% - 85%) - Longest step, now includes SHA512
    combined_log("Calculating hashes (may take a while)...")
    
    hash_results = {}
    
    # Define progress distribution for hashing (60% of total)
    hash_progress_total_range = 85 - 25
    hash_count = len(hash_algorithms)
    if hash_count == 0:
         hash_count = 1
    hash_progress_per_algo = hash_progress_total_range / hash_count 
    current_hash_progress_start = 25
    
    for algo_name in hash_algorithms:
        algo_upper = algo_name.upper()
        
        # Mapping string names to hashlib functions
        if algo_upper == 'SHA256':
            algo_func = hashlib.sha256
        elif algo_upper == 'SHA512':
            algo_func = hashlib.sha512
        elif algo_upper == 'SHA1':
            algo_func = hashlib.sha1
        elif algo_upper == 'MD5':
            algo_func = hashlib.md5
        else:
            combined_log(f"Warning: Unsupported hash algorithm skipped: {algo_upper}")
            continue

        current_hash_progress_end = current_hash_progress_start + hash_progress_per_algo
        
        hash_results[algo_upper] = compute_hash(
            iso_path, 
            algo_func, 
            combined_log, 
            current_hash_progress_start, 
            current_hash_progress_end, 
            progress_callback
        )
        current_hash_progress_start = current_hash_progress_end 

    progress_callback(85)
    combined_log("All selected hashes calculated.")

    # 5. Extract FPR and Save the Report (85% - 90%)
    fpr_from_pub = extract_fpr_from_pubkey(pubkey_file) or fpr

    report_lines = [
        f"File: {iso_path.name}",
        f"Size: {os.path.getsize(iso_path)} bytes",
        f"Generated: {datetime.utcnow().isoformat()}Z",
        f"Release dir: {dest_dir.resolve()}",
        "",
        "--- Signatures and Key ---",
        f"Signature (binary): {sig_bin.name}",
        f"Signature (armored): {sig_asc.name}",
        f"Public Key: {pubkey_file.name}",
        "",
        "--- Hashes ---",
    ]
    
    for algo, hex_digest in hash_results.items():
        report_lines.append(f"{algo}: {hex_digest}")
        
    report_lines.extend([
        "",
        "--- GPG Info ---",
        f"GPG Fingerprint: {fpr_from_pub}",
        f"GPG Key ID (long): {long_key_id}",
        "",
        "Notes:",
        "- If the key was auto-generated by this script, it has NO passphrase for automation convenience.",
        "- Keep helwan-key.asc safe and publish it so users can import and verify the signature."
    ])
    
    report = "\n".join(report_lines).strip()
    report_file.write_text(report, encoding="utf-8")
    combined_log("Report written.")
    progress_callback(90) # 90% complete

    # 6. Copy the ISO itself into the release folder (90% - 100%)
    iso_copy_path = dest_dir / iso_path.name
    try:
        shutil.copy2(iso_path, iso_copy_path)
        combined_log(f"ISO copy placed at {iso_copy_path.name}")
    except Exception:
        combined_log("Warning: Failed to copy the ISO to the release folder.")
        
    progress_callback(100)
    combined_log("Process finished successfully.")
    
    return report, dest_dir.resolve()
