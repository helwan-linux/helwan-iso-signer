#!/usr/bin/env python3
"""
signer_logic.py
Contains the core GPG signing and hashing logic, refactored for use in a GUI application.
"""
import subprocess, sys, hashlib, textwrap, tempfile, shutil, os
from pathlib import Path
from datetime import datetime

# Helper function to run system commands. Modified to log output via a callback.
def run(cmd, capture=False, check=True, log_callback=None):
    if log_callback:
        log_callback(f"Executing: {' '.join(cmd)}")
    
    if capture:
        # Run the command and capture output
        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if check and p.returncode != 0:
            raise RuntimeError(f"Command failed: {' '.join(cmd)}\n{p.stderr.strip()}")
        return p.stdout
    else:
        # Run the command directly
        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if check and p.returncode != 0:
            raise RuntimeError(f"Command failed: {' '.join(cmd)} (exit {p.returncode})\n{p.stderr.strip()}")
        # We capture output even when not explicitly asked, to log it if needed
        if log_callback:
             log_callback(f"Command Output:\n{p.stdout.strip()}")
        return None

# Function to compute the hash of a large file efficiently
def compute_hash(path, algo):
    h = algo()
    # Read the file in 1MB chunks to save memory
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1024*1024), b""):
            h.update(chunk)
    return h.hexdigest()

# Function to find the Fingerprint (FPR) of the first existing secret key
def find_existing_secret_fpr():
    # Use check=False here because gpg might exit with a non-zero code if no key is found
    out = run(["gpg", "--list-secret-keys", "--with-colons"], capture=True, check=False)
    if not out:
        return None
    lines = out.splitlines()
    for i, ln in enumerate(lines):
        if ln.startswith("sec:"):
            # Look for the FPR line after the secret key line
            for j in range(i+1, min(i+6, len(lines))):
                if lines[j].startswith("fpr:"):
                    parts = lines[j].split(":")
                    if len(parts) > 9:
                        return parts[9]
    return None

# Function to generate a new GPG key without a passphrase
def generate_no_pass_key(log_callback):
    batch = textwrap.dedent("""
    %no-protection
    Key-Type: RSA
    Key-Length: 4096
    Name-Real: Helwan ISO Signing
    Name-Comment: auto-generated by signer_logic.py
    Name-Email: helwan@localhost
    Expire-Date: 0
    %commit
    """).strip()
    log_callback("No secret key found — Auto-generating an unprotected key for signing (Security Warning).")
    
    tfpath = ""
    try:
        # Create a temporary batch file with key generation instructions
        with tempfile.NamedTemporaryFile("w", delete=False) as tf:
            tf.write(batch)
            tfpath = tf.name
        
        # Run GPG to generate the key
        run(["gpg", "--batch", "--gen-key", tfpath], log_callback=log_callback)
    finally:
        # Ensure the temporary file is deleted
        if Path(tfpath).exists():
            try:
                Path(tfpath).unlink()
            except Exception:
                pass
    return find_existing_secret_fpr()

# Function to export the public key to an armored file
def export_pubkey(fpr, outpath, log_callback):
    if fpr:
        run(["gpg", "--armor", "--output", str(outpath), "--export", fpr], log_callback=log_callback)
    else:
        # Export all keys if no specific FPR is provided
        run(["gpg", "--armor", "--output", str(outpath), "--export"], log_callback=log_callback)

# Function to extract the FPR from the exported public key file
def extract_fpr_from_pubkey(pubkeyfile):
    # Use --import-options show-only to read the key without importing it
    out = run(["gpg", "--with-colons", "--import-options", "show-only", "--import", str(pubkeyfile)], capture=True, check=False)
    if not out:
        return None
    for ln in out.splitlines():
        if ln.startswith("fpr:"):
            parts = ln.split(":")
            if len(parts) > 9:
                return parts[9]
    return None

# The new main execution function designed to work with a GUI
def execute_signing_process(iso_path_str, log_callback):
    """
    Executes the full signing process.
    :param iso_path_str: Path to the ISO file (string).
    :param log_callback: A function (e.g., self.log_to_gui) to log status updates.
    :return: A tuple (report_content, destination_directory_path)
    """
    iso_path = Path(iso_path_str)
    
    # Check if GPG is installed
    if shutil.which("gpg") is None:
        raise RuntimeError("gpg is not installed. Please install it first (e.g., apt install gnupg).")

    # Validate file existence
    if not iso_path.exists() or not iso_path.is_file():
        raise FileNotFoundError(f"ISO file not found: {iso_path}")

    # Setup output directory structure
    release_root = Path("release")
    release_root.mkdir(exist_ok=True)
    iso_basename = iso_path.stem
    dest_dir = release_root / iso_basename
    
    # Avoid overwriting existing directories by appending timestamp
    if dest_dir.exists():
        ts = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
        dest_dir = release_root / f"{iso_basename}_{ts}"
    dest_dir.mkdir(parents=True, exist_ok=False)

    # Define output file paths
    sig_bin = dest_dir / (iso_path.name + ".sig")
    sig_asc = dest_dir / (iso_path.name + ".sig.asc")
    pubkey_file = dest_dir / "helwan-key.asc"
    report_file = dest_dir / f"{iso_path.name}.report.txt"
    log_file = dest_dir / "sign_iso.log"

    # Simple logging function to save to file (in addition to GUI callback)
    def file_log(msg):
        with open(log_file, "a", encoding="utf-8") as L:
            L.write(f"{datetime.utcnow().isoformat()}Z  {msg}\n")
    
    # Combine file logging and GUI logging
    def combined_log(msg):
        file_log(msg)
        log_callback(msg)

    combined_log("Starting process")
    combined_log(f"Working — The output will be in: {dest_dir.resolve()}")

    # 1) Identify or Generate Secret Key
    fpr = find_existing_secret_fpr()
    if not fpr:
        fpr = generate_no_pass_key(combined_log)
            
    if not fpr:
        raise RuntimeError("No secret key found and none was generated.")

    # Get the long Key ID (last 16 characters of the FPR)
    long_key_id = fpr[-16:]
    combined_log(f"Using key FPR={fpr} LONG={long_key_id}")

    # 2) Create Detached Signatures (Binary and ASCII Armored)
    combined_log("Creating signatures...")
    try:
        # Binary signature
        run(["gpg", "--output", str(sig_bin), "--detach-sign", "--local-user", fpr, str(iso_path)], log_callback=combined_log)
        # ASCII Armored signature
        run(["gpg", "--armor", "--output", str(sig_asc), "--detach-sign", "--local-user", fpr, str(iso_path)], log_callback=combined_log)
        combined_log("Signatures created successfully.")
    except Exception as e:
        raise RuntimeError(f"Failed to create signature via gpg. (Is key protected by a passphrase?): {e}")

    # 3) Export Public Key
    combined_log(f"Exporting Public Key to: {pubkey_file.name}")
    export_pubkey(fpr, pubkey_file, combined_log)
    combined_log(f"Public key exported: {pubkey_file}")

    # 4) Calculate Hashes
    combined_log("Calculating hashes (may take a while)...")
    sha256 = compute_hash(iso_path, hashlib.sha256)
    sha1   = compute_hash(iso_path, hashlib.sha1)
    md5    = compute_hash(iso_path, hashlib.md5)
    combined_log("Hashes calculated.")

    # 5) Extract FPR from exported key for report verification
    fpr_from_pub = extract_fpr_from_pubkey(pubkey_file) or fpr

    # 6) Save the Report
    report = textwrap.dedent(f"""\
    File: {iso_path.name}
    Size: {os.path.getsize(iso_path)} bytes
    Generated: {datetime.utcnow().isoformat()}Z
    Release dir: {dest_dir.resolve()}

    Signature (binary): {sig_bin.name}
    Signature (armored): {sig_asc.name}
    Public Key: {pubkey_file.name}

    SHA256: {sha256}
    SHA1:   {sha1}
    MD5:    {md5}

    GPG Fingerprint: {fpr_from_pub}
    GPG Key ID (long): {long_key_id}

    Notes:
    - If the key was auto-generated by this script, it has NO passphrase for automation convenience.
    - Keep helwan-key.asc safe and publish it so users can import and verify the signature.
    """).strip()
    report_file.write_text(report, encoding="utf-8")
    combined_log("Report written.")

    # 7) Copy the ISO itself into the release folder
    iso_copy_path = dest_dir / iso_path.name
    try:
        shutil.copy2(iso_path, iso_copy_path)
        combined_log(f"ISO copy placed at {iso_copy_path.name}")
    except Exception:
        combined_log("Warning: Failed to copy the ISO to the release folder.")
        
    combined_log("Process finished successfully.")
    
    # Return key results to the GUI
    return report, dest_dir.resolve()
